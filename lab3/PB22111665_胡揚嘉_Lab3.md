# 数字图像处理与分析 Lab3

**PB22111665 胡揚嘉**

## 实验目的

本次实验主要是通过matlab实现有关空间域滤波的问题

这里的主要研究对象是图像的空间域层面上，怎么对噪声进行处理，具体常用的方法是各种滤波。

更加明确的说，实质上是在每个像素的邻域，观察其是否在满足一定的`噪声`特性，按照一定的阈值原则进行筛选，以期达到滤波的效果，最重要的是，观察其对图像边缘的区分和模糊影响

具体而言包括：

+ 均值滤波和超限邻域平均法
+ 中值滤波和超限中值滤波
+ 前四种方法的对比
+ 边缘检测的算法，包括一阶算子和二阶算子

## 实验内容

### Lab1 生成对应的噪声图像

#### 代码和分析

```matlab
% 用原始图像 lena.bmp 或 cameraman.bmp 分别加产生的 3%椒盐噪声、高斯噪声、随机噪声合成有噪声的图像并显示

image = imread("/home/ubuntu/Downloads/matlab/lab3/fig/cameraman.bmp");

% 添加椒盐噪声
pepper_noise = imnoise(image, 'salt & pepper', 0.03);

% 添加高斯噪声 , mu=0, sigma=0.1
gaussian_noise = imnoise(image, 'gaussian', 0, 0.03); 

% 添加随机噪声(乘性噪声)
random_noise = imnoise(image, 'speckle', 0.03);

% 显示原始图像和噪声图像
subplot(2, 2, 1);
imshow(image);
title('原始图像');

subplot(2, 2, 2);
imshow(pepper_noise);
title('椒盐噪声图像');

subplot(2, 2, 3);
imshow(gaussian_noise);
title('高斯噪声图像');

subplot(2, 2, 4);
imshow(random_noise);
title('随机噪声图像');


% 保存相关图像
saveas(gcf, '/home/ubuntu/Downloads/matlab/lab3/fig/subplot.png');
filename = '/home/ubuntu/Downloads/matlab/lab3/fig/'; % 定义文件名
imwrite(pepper_noise, [filename  'pepper_noise.png']); % 保存椒盐噪声图像
imwrite(gaussian_noise, [filename 'gaussian_noise.png']); % 保存高斯噪声图像
imwrite(random_noise, [filename 'random_noise.png']); % 保存随机噪声图像
```

分析：

1. 对于每个图像，生成对应的含有`3%椒盐噪声、高斯噪声、随机噪声`的图像

2. 使用函数`imnoise`实现，指定添加噪声的类型和噪声的水平，

   高斯噪声是均值和方差

   随机噪声和椒盐噪声是噪声的水平

#### 实现结果

![alt text](./fig/subplot.png)

下面所有的处理和分析都基于这样的噪声图像进行

### Lab2 均值滤波

#### 代码和分析

```matlab
% 均值滤波

filename = '/home/ubuntu/Downloads/matlab/lab3/fig/';
image = imread([filename 'cameraman.bmp']);
image_pepper = imread([filename 'pepper_noise.png']);
image_gaussian = imread([filename 'gaussian_noise.png']);
image_random = imread([filename 'random_noise.png']);

% 均值滤波
filter_average = fspecial('average', 3);

image_average_pepper = imfilter(image_pepper, filter_average);
image_average_gaussian = imfilter(image_gaussian, filter_average);
image_average_random = imfilter(image_random, filter_average);

% 显示原始图像和均值滤波图像
subplot(2, 4, 1);
imshow(image);
title('原始图像');

subplot(2, 4, 2);
imshow(image_pepper);
title('椒盐噪声图像');

subplot(2, 4, 3);
imshow(image_gaussian);
title('高斯噪声图像');

subplot(2, 4, 4);
imshow(image_random);
title('随机噪声图像');

subplot(2, 4, 6);
imshow(image_average_pepper);
title('均值滤波椒盐噪声图像');

subplot(2, 4, 7);
imshow(image_average_gaussian);
title('均值滤波高斯噪声图像');

subplot(2, 4, 8);
imshow(image_average_random);
title('均值滤波随机噪声图像');

% 调整子图间距
set(gcf, 'Position', get(0,'Screensize')); % 使图形窗口最大化
% subplots_adjust('hspace', 0.5); % 增加垂直间距

% 保存均值滤波结果
saveas(gcf, [filename 'subplot_average.png']);
```

分析：

1. 将以像素为中心，[3，3]范围的像素灰度求均值，作为当下图像的灰度
2. `fspecial('average', 3);`指定滤波函数，这里指定到3*3的均值滤波
3. `imfilter(image_pepper, filter_average);`将生成的滤波器执行到每种带噪图像上，得到结果

#### 实现结果

![](./fig/subplot_average.png)

可以观察得到：

1. 均值滤波对椒盐噪声效果很好，但是对随机噪声和高斯噪声效果不好

   1. 原因是：椒盐噪声通常是图像中的稀疏、孤立的高亮或低亮像素点，均值滤波通过取邻域像素的平均值，可以有效平滑这些孤立点，从而去除椒盐噪声。然而，随机噪声和高斯噪声通常在整个图像中分布较为均匀，且其强度变化较为平滑，均值滤波在平滑这些噪声的同时，也会平滑掉图像的细节和边缘信息，导致去噪效果不佳。

2. 均值滤波会对图像的边缘产生模糊现象，原因是：均值滤波在计算每个像素的新值时，考虑了其邻域内所有像素的值，包括边缘两侧的像素。这会导致边缘两侧的像素值相互影响，从而模糊了边缘的界限。

   可能的解决方法是：采用超限均值滤波

### Lab3 超限均值滤波

#### 代码和分析

```matlab
% 似乎没有直接的函数实现

% 与均值滤波，相比，每个像素在均值前后的差值决定了选择均值还是原值，可以利用这一点做文章
filename = '/home/ubuntu/Downloads/matlab/lab3/fig/';
image = imread([filename 'cameraman.bmp']);
image_pepper = imread([filename 'pepper_noise.png']);
image_gaussian = imread([filename 'gaussian_noise.png']);
image_random = imread([filename 'random_noise.png']);

% 均值滤波
filter_average = fspecial('average', 3);

% image_average_pepper_tmp = imfilter(image_pepper, filter_average);
% image_average_gaussian_tmp = imfilter(image_gaussian, filter_average);
% image_average_random_tmp = imfilter(image_random, filter_average);

image_average_pepper = myFun(image_pepper);
image_average_gaussian = myFun(image_gaussian);
image_average_random = myFun(image_random);

% 显示原始图像和均值滤波图像
subplot(2, 4, 1);
imshow(image);
title('原始图像');

subplot(2, 4, 2);
imshow(image_pepper);
title('椒盐噪声图像');

subplot(2, 4, 3);
imshow(image_gaussian);
title('高斯噪声图像');

subplot(2, 4, 4);
imshow(image_random);
title('随机噪声图像');

subplot(2, 4, 6);
imshow(image_average_pepper);
title('超限邻域椒盐噪声图像');

subplot(2, 4, 7);
imshow(image_average_gaussian);
title('超限邻域高斯噪声图像');

subplot(2, 4, 8);
imshow(image_average_random);
title('超限邻域随机噪声图像');

subplot(2, 4, 5);
imshow(imfilter(image_pepper, filter_average));
title('均值滤波椒盐噪声图像');

% 调整子图间距
set(gcf, 'Position', get(0,'Screensize')); % 使图形窗口最大化

% 保存均值滤波结果
saveas(gcf, [filename 'subplot_overlimit.png']);


function result = myFun(input)
%myFun - Description
%
% Syntax: output = myFun(input)
%
% Long description
    % 得到均值滤波后的图像
    filter_average = fspecial('average', 3);
    image_tmp = imfilter(input, filter_average);
    
    % 计算差值
    T = 50;
    place = abs(input - image_tmp) > T;

    % 应用超限邻域平均法
    result = input; 
    result(place) = image_tmp(place); 
    % 返回结果
    return;
end

```

分析：

1. 灰度直方图的思想是：统计整个图像，每一个像素的灰度，并且将其转化为一个图表以供参考
1. `histcounts`: 这是 MATLAB 中用于计算直方图计数的函数。它统计输入数据落在指定箱（bin）中的数量。这个函数主要实现了统计直方图的功能。

#### 实现结果

> 请输入a:2
> 请输入b:1.5

自左向右分别是：原图，最近邻插值，双线性插值的结果
![alt text](image3_move.jpg)

### Lab4 直方图均衡化

#### 代码和分析

```matlab
image = imread('/home/ubuntu/Downloads/matlab/lab2/fig/pout.bmp');
subplot(3,2,1);
imshow(image);
title('原始图像');
subplot(3,2,2);
% histogram函数，用于显示图像的直方图
histogram(image);
title('原始图像直方图');

% histeq函数用于直方图均衡化
image2 = histeq(image);
subplot(3,2,3);
imshow(image2);
title('直方图均衡化后的图像');
subplot(3,2,4);
histogram(image2);
title('直方图均衡化后的图像直方图');


% 规定化需要一个目标直方图，而且是高斯分布的，使用 normpdf((0:1:255), 128, 50)产生
% normpdf(x,mu,sigma)，由于像素是离散的256哥点，所以x=0:1:255，均值mu=128，标准差sigma=50是自己设置的
image3 = histeq(image, normpdf((0:1:255), 128, 50));
subplot(3,2,5);
imshow(image3);
title('直方图规定化后的图像');
subplot(3,2,6);
histogram(image3);
title('直方图规定化后的图像直方图');
```



总结：

- 这里执行了两种变化。第一种是均衡化，第二种是规定化，并且指定的是高斯分布
- `image2 = histeq(image);`不加其他参数，执行直方图均衡化，期望最后输出的直方图更加均衡，各个灰度的出现频率相当
- `image3 = histeq(image, normpdf((0:1:255), 128, 50));`加上一个参数，指定希望规定化的情形，本质上是，这使用` normpdf((0:1:255), 128, 50)`产生通过一个高斯分布的目标直方图

#### 实现结果

> 输入通过 `cpselect`函数的选点实现

自左向右分别是：标准图像，失真图像，校正图像

![alt text](image4_move.jpg)


## 实验总结

1. 本次实验主要是通过matlab实现有关 `图像点处理增强`的内容。主要通过像素角度和直方图角度进行分析
2. 通过本次实验，熟悉了图像的灰度的操控与处理，又通过矩阵运算批量处理 的简单情况，也有全局遍历，按照自己的需求针对性处理的复杂方法
3. 还探究了与直方图相关的情况，包括输出直方图，在直方图的基础上进行处理等。
